/* Created: 21.07.2016
 * Delay.c
 *
 *
 *
 */

#include "stm32f10x.h"
#include "Delay.h"

//uint8_t FlagTim2Cmp = 0;
uint8_t Flag;
uint16_t Delay = 0;

//*************************************************************************************************
//Настройка таймера для циклического опроса датчиков (частота 1с)
void TimInitForSensor(void)
{        		 
  NVIC_SetPriority (TIM2_IRQn, 5);		//назначить приоритет прерывания от таймера 2 
  NVIC_EnableIRQ (TIM2_IRQn);				  //глобальное разрешение прерываения таймера 2
  
  RCC->APB1ENR |=RCC_APB1ENR_TIM2EN;		//включить тактирование таймера 2
  DelayTimer->PSC = 720; 				//предделитель таймера (при 36МГц, делителе 36000, после деления 1КГц - 10мс	
  DelayTimer->ARR = 50000;					  		//значение предзагрузки/перезагрузки	(1s)	
  DelayTimer->CR1 |= TIM_CR1_URS;			//обновление с помощью бита UG не устанавливает флаг прерывания
  DelayTimer->EGR |= TIM_EGR_UG;				//генерация события обновления  
  DelayTimer->DIER |= TIM_DIER_UIE;			//включить вызов прерывания от события от таймера
  
  DelayTimer->CR1 |= TIM_CR1_CEN;			//включение таймера	
  //TIM2->SR &= ~TIM_SR_UIF;
}

//*************************************************************************************************
//функция задержки инциализации тайаера для использования в задержках
void DelayTimInit (void)
{        
  NVIC_EnableIRQ (TIM2_IRQn);				  //включить прерываени таймера 2			 
  NVIC_SetPriority (TIM2_IRQn, 5);		//назначить приоритет прерывания от таймера 2
   
  RCC->APB1ENR |=RCC_APB1ENR_TIM2EN;		//включить тактирование таймера 2
  DelayTimer->CR1 |= TIM_CR1_OPM;						//режим одиночного запуска счёта таймера
  DelayTimer->CR1 |= TIM_CR1_URS;							//обновление с помощью бита UG не устанавливает флаг прерывания
  DelayTimer->DIER |= TIM_DIER_UIE;					//включить прерывание от таймера       
}

//*************************************************************************************************
//функция задержки для ожидания передачи последнего байта по USART
void DelayTimeInitForUSART (void)
{
//	NVIC_EnableIRQ (TIM2_IRQn);				  //включить прерываени таймера 2			 
//  NVIC_SetPriority (TIM2_IRQn, 5);		//назначить приоритет прерывания от таймера 2
//  
//  RCC->APB1ENR |=RCC_APB1ENR_TIM2EN;	//включить тактирование таймера 2
//  DelayTimer->CR1 |= TIM_CR1_OPM;			//режим одиночного запуска счёта таймера
//  DelayTimer->CR1 |= TIM_CR1_URS;			//обновление с помощью бита UG не устанавливает флаг прерывания
//  DelayTimer->DIER |= TIM_DIER_UIE;		//включить прерывание от таймера   
	DelayTimer->PSC = PRESKALER; 				//предделитель таймера (при 36МГц, делителе 36, после деления 1KГц - 1мс		
  //TIM2->CR1 |= TIM_CR1_OPM;					//включить автопредзагрузку/перезагрузку, режим одиночного запуска счёта таймера ( TIM_CR1_ARPE |)
  //Delay = Delay<<1;										//умножить на 2 задержку, т.к. частота таймера в 2 раза больше
  DelayTimer->ARR = 20;					  		//значение предзагрузки/перезагрузки	(10ms)
  DelayTimer->EGR |=TIM_EGR_UG;				//генерация события обновления
  DelayTimer->CNT = 0x01;	
}

//*************************************************************************************************
//функция задержки, шаг 1мкс, максимальное время 65536мкс, задержка цикл (ошибка 1.84 мкс на частоте 72 МГц, накладные расходы на вызов прерывания + настройка таймера)	
void Delay_us(uint16_t Delay)
{
  DelayTimer->PSC = 23; 								   	//CLK_DIV  The counter clock frequency CK_CNT is equal to fCK_PSC / (PSC[15:0] + 1). предделитель таймера (при 36МГц, делителе 36, после деления 1МГц - 1мкс		
  //TIM2->CR1 |= TIM_CR1_OPM;												  //режим одиночного запуска счёта таймера ( TIM_CR1_ARPE |)
  DelayTimer->ARR = Delay;														//значение предзагрузки/перезагрузки
  DelayTimer->EGR |=TIM_EGR_UG;													  //генерация события обновления 
  DelayTimer->CNT = 0x01;										//счёт от единицы, т.к. счёт от 0 даёт лишний тик
  Flag = 0;			
  //TIM2->DIER |= TIM_DIER_UIE;
  DelayTimer->CR1 |= TIM_CR1_CEN;													//включение таймера				
  //while (TIM2->CR1 & (TIM_CR1_CEN!=0));
  while (Flag==0);
}	
//*************************************************************************************************
//функция задержки, шаг 1мс, максимальное время 65536мс, задержка цикл
void Delay_ms (uint16_t Delay)
{ 
  DelayTimer->PSC = PRESKALER; 									  //предделитель таймера (при 36МГц, делителе 36, после деления 1KГц - 1мс		
  //TIM2->CR1 |= TIM_CR1_OPM;											  //включить автопредзагрузку/перезагрузку, режим одиночного запуска счёта таймера ( TIM_CR1_ARPE |)
  Delay = Delay<<1;													  		//умножить на 2 задержку, т.к. частота таймера в 2 раза больше
  DelayTimer->ARR = Delay;														    //значение предзагрузки/перезагрузки	
  DelayTimer->EGR |=TIM_EGR_UG;													//генерация события обновления
  DelayTimer->CNT = 0x01;			
  Flag = 0;
  //TIM2->DIER |= TIM_DIER_UIE;
  DelayTimer->CR1 |= TIM_CR1_CEN;													//включение таймера		
  //while (TIM2->CR1 & (TIM_CR1_CEN!=0));
  while (Flag==0);
}
    
//************************************************************************************************
//
void _delay_us(uint32_t __us)
{
  //uint32_t __ticks;
  uint32_t __tmp = (F_CPU / 1e6) * __us;//double __tmp = ((F_CPU) / 3e6) * __us;  коэфицет 4 число тактов в цикле на команды ассемблера
  //__ticks = (uint32_t)__tmp;
  _delay_loop(__tmp);
}

//************************************************************************************************
//
void _delay_ms(uint32_t __ms)
{
  //uint32_t __ticks;
  uint32_t __tmp = (F_CPU / 1e3) * __ms;//double __tmp = ((F_CPU) / 3e3) * __ms;
  //__ticks = (uint32_t)__tmp;
  _delay_loop(__tmp);
}

//************************************************************************************************
//
__asm void _delay_loop(uint32_t __count)
{
loop SUBS r0,r0,#1
     BNE loop
     BX lr
}    
		
		

////************************************************************************************************
////
//void _delay_us(double __us)
//{
//  uint32_t __ticks;
//  double __tmp = ((F_CPU) / 4e6) * __us;//double __tmp = ((F_CPU) / 3e6) * __us;
//  __ticks = (uint32_t)__tmp;
//  _delay_loop(__ticks);
//}

////************************************************************************************************
////
//void _delay_ms(double __ms)
//{
//  uint32_t __ticks;
//  double __tmp = ((F_CPU) / 4e3) * __ms;//double __tmp = ((F_CPU) / 3e3) * __ms;
//  __ticks = (uint32_t)__tmp;
//  _delay_loop(__ticks);
//}

////************************************************************************************************
////
//__asm void _delay_loop(uint32_t __count)
//{
//loop SUBS r0,r0,#1
//     BNE loop
//     BX lr
//}

